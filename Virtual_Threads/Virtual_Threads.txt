Virtual Threads, introduced as a stable feature in Java 21 as part of Project Loom, are lightweight, user-mode threads managed by the Java Virtual Machine (JVM). They differ significantly from traditional platform threads (OS threads) in their resource consumption and scalability.
Differences from Traditional Platform Threads:
Resource Consumption: Platform threads are directly mapped to operating system (OS) threads, which are relatively heavy, requiring significant memory for their stack and context. Virtual threads, in contrast, are managed by the JVM, multiplexing many virtual threads onto a smaller number of platform threads. This makes them significantly lighter and allows for the creation of millions of virtual threads with minimal overhead.
Scalability: Due to their lightweight nature, virtual threads enable Java applications to achieve 
much higher concurrency levels than platform threads. This is particularly beneficial for 
I/O-bound applications, where threads spend a lot of time waiting for external resources.
Scheduling: The JVM handles the scheduling of virtual threads, parking them when they block and
unparking them when they are ready to run, without involving the OS scheduler. This allows 
for more efficient resource utilization.
Programming Model: Virtual threads retain the familiar Thread API, allowing developers to 
write blocking code in a straightforward, imperative style without needing to adopt complex
asynchronous programming models like futures or reactive programming for high concurrency.


New Concurrency Utilities: Virtual Threads (Java 21)
Java 21 introduced Virtual Threads (Project Loom), a groundbreaking change to Java's concurrency 
model. They are lightweight threads implemented entirely within the JVM, designed to 
dramatically reduce the cost and complexity of high-throughput concurrent applications.

Platform Threads (Traditional): Heavyweight, OS-managed threads. Limited in number 
(often thousands max) due to memory and context-switching overhead.

Virtual Threads (New): Extremely lightweight threads that are scheduled by the JVM onto a 
small pool of carrier platform threads. You can create millions of them.

===============================================================================

In the Java code snippet try (var executor = Executors.newVirtualThreadPerTaskExecutor()), 
var is a reserved type name (often referred to as a keyword in common parlance) introduced in 
Java 10. It is used for local variable type inference.
Here's a breakdown:
var as a Reserved Type Name: While not a traditional keyword like public or class, var holds a 
special meaning within the Java language, making it a reserved identifier that cannot be used 
for variable names or other identifiers.
Local Variable Type Inference: When var is used to declare a local variable, the Java compiler
automatically infers the variable's type based on the type of the initializer expression on the 
right-hand side of the assignment. In this case, Executors.newVirtualThreadPerTaskExecutor() 
returns an ExecutorService, so the compiler infers that executor will be of type ExecutorService.
Benefits: Using var can lead to more concise and readable code, especially when dealing with long 
or complex type names. It reduces redundancy by eliminating the need to explicitly declare the 
type when it can be easily inferred by the compiler.
Context: var is only applicable to local variables and cannot be used for fields, method 
parameters, or return types.

Benefit: Virtual Threads are cheap to create and block when waiting for I/O (like network 
or database calls), freeing up the underlying carrier thread to serve other virtual threads. 
This enables massive scalability for server applications with high concurrency demands.
