Java concurrency mechanisms allow multiple threads to execute simultaneously, improving 
performance and responsiveness. However, this introduces challenges related to coordination 
and visibility.
ðŸ”’ Synchronization Primitives These mechanisms are used to control thread access to shared 
resources and manage thread communication.
1. synchronized Blocks and MethodsThe synchronized keyword is the most fundamental way to 
achieve thread safety in Java by ensuring that only one thread can execute a block of code 
or a method at a time. It uses an intrinsic lock (monitor lock) associated with an object.
Mechanism: When a thread enters a synchronized block, it acquires the lock on the specified 
object (or the class object for static methods). Once the block is exited, the lock is
released. 
Visibility: It guarantees that all variables modified inside the synchronized block are 
visible to the next thread that acquires the same lock (happens-before relationship).
Usage: Method Synchronization: public synchronized void increment() { count++; } 
(locks the instance). Block Synchronization: synchronized (lockObject) { ... } 
(locks a specific object).
2. volatile KeywordThe volatile keyword guarantees that reads and writes to a variable are 
performed directly to and from main memory, ensuring visibility across threads. 
Mechanism: It prevents the CPU from caching the variable's value locally in a register 
or private cache. Every read sees the latest write, and every write is immediately made 
visible to other threads.
Limitation: volatile only ensures visibility; it does not guarantee atomicity for compound 
operations (e.g., i++, which is a read, modify, write operation). 
For atomic operations, use java.util.concurrent.atomic classes or synchronized.
3. Reentrant Lock Reentrant Lock (part of java.util.concurrent.locks) is a more flexible 
and powerful alternative to the synchronized keyword. Mechanism: It offers the same mutual 
exclusion but provides features like interruptible waiting (lockInterruptibly()), 
timed waiting (tryLock(long timeout)), and fairness (first thread waiting gets the lock
first). Reentrancy: A thread that owns the lock can reacquire it without blocking 
(hence "reentrant"). Usage: Requires manual locking and unlocking, typically using a 
try-finally block to ensure the lock is always released.
4. Count Down Latch A synchronization aid that allows one or more threads to wait until a 
set of operations being performed by other threads completes. Mechanism: It's initialized 
with a count. Threads call await() to block until the count reaches zero. Other threads 
call countDown() to decrement the count. Usage: Useful for starting an application only 
after all necessary services have initialized, or for waiting for a collection of parallel 
tasks to finish.
5. Semaphore A synchronization aid that maintains a set of available permits. Threads must 
acquire a permit to access a resource and release it when done. Mechanism: Used to control 
access to a limited pool of resources. If the count is 1, a Semaphore acts like a binary 
mutex. If the count is $N$, it allows up to $N$ threads to access the resource concurrently.
Usage: Limiting the number of concurrent connections to a database or restricting access to 
a limited number of physical devices.
ðŸš€ Asynchronous Task Management
6. Completable Future Completable Future (Java 8+) is used for composing and managing 
asynchronous tasks. It represents a result that may not yet be available and is a powerful 
tool for reactive programming. Mechanism: It can be completed explicitly 
(complete(T value)) or can be built using fluent methods (thenApply, thenAccept, allOf, 
anyOf) to define a pipeline of asynchronous computations. It eliminates callback hell.
Advantages: Non-blocking, highly efficient, and simplifies complex workflows where one task 
depends on the completion or result of another.

Concurrency Issues and Avoidance Strategies
Issue                      Description                     Avoidance Strategy

Race Condition             Occurs when the correctness     Use synchronized, ReentrantLock,
                           of the program depends on the   or Atomic classes to ensure mutual
                           unpredictable sequence or       exclusion over critical sections.
                           timing of multiple threads 
                           accessing shared data.

Deadlock	                 Two or more threads are         Impose a strict, global ordering
                           perpetually blocked, waiting    of locks: All threads must acquire
                           for resources held by the       locks in the same sequence
                           other, leading to a permanent   (e.g., Lock A before Lock B).
                           halt in progress.                Use tryLock() with a timeout to back
                                                            out of a deadlock attempt.

Livelock	                 Threads continuously change      Introduce randomness or time-based
                           their state in response to       backing off into the retry logic
                           each other without making any    so threads do not repeatedly 
                           progress (e.g., two people       attempt the same action simultaneously.
                           politely trying to avoid each 
                           other in a hallway).

======================================================================

Java's CompletableFuture class, introduced in Java 8, is a powerful tool for asynchronous 
programming and handling the results of computations that might not be immediately 
available. It extends the Future interface, offering significant enhancements for 
composing and combining asynchronous tasks, handling exceptions, and reacting to 
completion.
Key functions and benefits of CompletableFuture:
Asynchronous Execution: It allows tasks to be run in a separate thread, freeing up the 
main thread to perform other operations. This is crucial for improving responsiveness 
in applications, especially those involving I/O-bound operations like network requests
or database access.
Chaining and Composition: CompletableFuture enables the chaining of dependent operations. 
You can define what should happen after a task completes, transform its result, or combine 
it with the results of other CompletableFuture instances. Methods like thenApply, 
thenCompose, thenCombine, and allOf facilitate these operations.
Non-Blocking Operations: Unlike the traditional Future's get() method which blocks until 
the result is available, CompletableFuture supports non-blocking operations. You can register callbacks that execute when a computation completes, allowing for more efficient resource 
utilization.
Exception Handling: It provides robust mechanisms for handling exceptions that occur 
during asynchronous computations. Methods like exceptionally and handle allow you to 
define how to react to errors and recover gracefully.
Manual Completion: You can manually complete a CompletableFuture using complete(T value) 
or completeExceptionally(Throwable ex), which is useful when the result of a computation 
is determined outside of a traditional asynchronous task.
Functional Programming Style: CompletableFuture leverages Java's functional programming 
features, such as lambda expressions and method references, making the code more concise
and readable for managing asynchronous workflows.
In essence, CompletableFuture simplifies the development of concurrent and asynchronous
applications by providing a flexible and expressive API for managing the lifecycle and 
interactions of asynchronous computations.
