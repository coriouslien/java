The JMM defines how threads interact with memory and ensures visibility of changes made by one 
thread to another. It involves concepts like main memory and working memory for each thread, and 
keywords like volatile and synchronized help enforce visibility and ordering.

The Java Memory Model (JMM) is a specification that defines how threads interact through memory 
in a multithreaded Java application, providing guarantees about the visibility and ordering of 
memory operations across different threads. The JMM ensures consistent behavior even in the 
presence of aggressive compiler optimizations and hardware caches that might otherwise 
reorder instructions or keep stale data in local memory. 
The central concept in the JMM is the happens-before relationship, a partial ordering that 
guarantees that the effects of one action are visible to another. If action A happens-before 
action B, then the results of A are guaranteed to be visible to the thread performing B. 
The JMM defines rules that establish this relationship, including program order within a 
single thread, monitor lock and unlock operations, and interactions involving volatile 
variables, thread start, and thread join. 
Below are code examples illustrating JMM concepts. 
Example 1: The Visibility Problem
This example demonstrates how a change to a shared variable by one thread might not be visible 
to another without proper synchronization, potentially leading to issues like infinite loops. 
For a full code example. 
Explanation: Without proper synchronization, a worker thread might not see changes made to a 
shared variable by another thread, potentially causing unexpected behavior like an infinite loop. 
Example 2: Solving Visibility with volatile
Marking a shared variable as volatile guarantees that writes are flushed to main memory and 
reads fetch the latest value, establishing a happens-before relationship. For a full code 
example, please refer to CodeSignal. 
Explanation: The volatile keyword ensures that changes to the variable are visible across threads. 
Example 3: Solving Visibility with synchronized
Synchronization provides both mutual exclusion and happens-before guarantees. An unlock operation 
by one thread happens-before a subsequent lock by another thread on the same monitor. For a full 
code example, please refer to CodeSignal. 
Explanation: Using synchronized methods or blocks ensures that reads and writes to shared 
variables are properly ordered and visible across threads.

The Java Memory Model (JMM) defines the rules regarding how threads interact with memory. It 
specifies two crucial things: how and when changes made by one thread become visible to another 
thread, and how synchronization mechanisms affect memory ordering. The JMM exists primarily 
to bridge the gap between Java's high-level language guarantees and the complexities of modern 
multi-core hardware and compiler optimizations.

ðŸ§  1. The Core Problem: Caching and Reordering Modern systems achieve performance by using 
three main techniques that violate sequential code execution: Processor Caches: Each CPU core 
has its own cache (L1, L2, L3). When a thread writes to a variable, the write might only go 
to the local CPU cache, not main memory. Other threads on different cores may continue 
reading stale values from their caches. Compiler Optimization: The JVM and JIT compiler 
may reorder instructions to improve efficiency, as long as the code appears correct to a single 
thread (the as-if-serial guarantee). Hardware Reordering: The CPU hardware itself can reorder 
memory writes for performance.The JMM exists to prevent these optimizations from breaking 
multi-threaded logic.

ðŸ”’ 2. Key JMM Concepts A. Happens-Before Relationship (The Core Guarantee)The "happens-before"
relationship is the JMM's central concept. If action $A$ happens-before action $B$, the JMM 
guarantees that: Visibility: The effects of action $A$ are visible to action $B$.Ordering: 
Action $A$ is executed before action $B$. If there is no happens-before relationship between two
actions, the JVM is free to reorder them, leading to a race condition. B. Happens-Before Rules
(Enforcing Visibility) The JMM defines several explicit rules that establish a happens-before
relationship:

Mechanism	          Action A (Happens Before)	               Action B (Is Visible To)
Volatile            A write to a volatile variable.          A subsequent read of that same 
                                                             volatile variable.

Synchronization     An unlock of a monitor (releasing        A subsequent lock of that same monitor.
                    a synchronized block).

Thread Start/Join   Calling t.start().                       The first action in thread $t$.

Thread Join         All actions in thread $t$.               The successful return from t.join().


=====================================================================================
A comprehensive example demonstrating Java Memory Model visibility problems and their solutions
Problems Demonstrated:

Visibility Problem: A thread may never see changes made by another thread due to CPU caching (the background thread might run forever)
Lost Updates: Multiple threads incrementing a counter without synchronization leads to lost updates (race condition)
Instruction Reordering: The JVM/CPU can reorder instructions, leading to unexpected results

Solutions Provided:

volatile keyword: Ensures visibility of changes across threads
synchronized methods: Provides both atomicity and visibility
AtomicInteger: Lock-free atomic operations for better performance

Key Takeaways:

Without volatile or synchronization, changes made in one thread may never be visible to others
count++ is NOT atomic - it's three operations: read, increment, write
Use volatile for simple flags that are only read/written
Use synchronized or AtomicInteger when you need compound operations to be atomic

Run this code multiple times to see the non-deterministic nature of concurrency bugs - sometimes the problems manifest, sometimes they don't, which makes them particularly dangerous in production code.
